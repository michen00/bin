#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME=$(basename "$0")
DEFAULT_FILE=".git-blame-ignore-revs"
INCLUDE_SUMMARY=true

HELP=$(
	cat <<EOF
Usage: $SCRIPT_NAME [HASH] [FILE]

Adds the given Git commit hash to a specified file (default: $DEFAULT_FILE).
If HASH is not provided, the last commit hash is used.

Options:
  HASH          Git commit hash to add. If omitted, uses the last commit.
  FILE          File to update. Defaults to "$DEFAULT_FILE".
  --no-summary  Do not include the commit summary in the file.
  -h, --help    Show this help message and exit.

Examples:
  $SCRIPT_NAME                     # Use last commit hash, update default file
  $SCRIPT_NAME abc1234             # Use given hash, update default file
  $SCRIPT_NAME abc1234 custom.txt  # Use given hash, update custom file
  $SCRIPT_NAME --no-summary        # Use last commit hash, omit summary
EOF
)

# Parse arguments
POSITIONAL=()
while [[ $# -gt 0 ]]; do
	case "$1" in
	-h | --help)
		echo "$HELP"
		exit 0
		;;
	--no-summary)
		INCLUDE_SUMMARY=false
		shift
		;;
	*)
		POSITIONAL+=("$1")
		shift
		;;
	esac
done
set -- "${POSITIONAL[@]}"

HASH_ARG=${1:-}
FILE=${2:-$DEFAULT_FILE}

# Check we're in a git repository
if [ ! -d .git ]; then
	echo "Error: Must be run from the root of a git repository." >&2
	exit 1
fi

# State tracking for cleanup
STASHED=false
STASH_MSG="ach: auto-stash $FILE"
OTHER_STAGED_FILES=""
FILE_MODIFIED=false
ORIGINAL_CONTENT=""

# Helper to re-stage files, skipping any that no longer exist
restage_other_files() {
	if [[ -z $OTHER_STAGED_FILES ]]; then
		return 0
	fi
	echo "Re-staging other files..."
	while IFS= read -r f; do
		if [[ -n "$f" && -e "$f" ]]; then
			# Use || true to prevent script exit on git add failure
			git add -- "$f" || echo "Warning: Failed to re-stage '$f'" >&2
		elif [[ -n "$f" ]]; then
			echo "Warning: '$f' no longer exists (was it a new file?)" >&2
		fi
	done <<<"$OTHER_STAGED_FILES"
	return 0
}

# Cleanup function to restore state on error
# shellcheck disable=SC2329
cleanup() {
	local exit_code=$?
	# Restore file if we modified it but didn't commit
	if [[ $FILE_MODIFIED == true && -n $ORIGINAL_CONTENT ]]; then
		echo "Restoring original $FILE..." >&2
		printf '%s' "$ORIGINAL_CONTENT" >"$FILE"
	fi
	# Restore stashed changes
	if [[ $STASHED == true ]] && git stash list | head -1 | grep -qF "$STASH_MSG"; then
		echo "Restoring stashed changes to $FILE..." >&2
		git stash pop --quiet
	fi
	# Re-stage other files
	restage_other_files
	exit "$exit_code"
}
trap cleanup EXIT

# Validate/get commit hash
if [ -z "$HASH_ARG" ]; then
	echo "Getting the last commit hash..."
	HASH_ENTRY=$(git log -1 --pretty=format:"%H" 2>/dev/null || echo "")
	if [ -z "$HASH_ENTRY" ]; then
		echo "Error: No prior commits found. Please make an initial commit first." >&2
		exit 1
	fi
else
	HASH_ENTRY="$HASH_ARG"
fi

if ! git cat-file -e "$HASH_ENTRY" 2>/dev/null; then
	echo "Error: Invalid commit hash: $HASH_ENTRY" >&2
	exit 1
fi
HASH_ENTRY=$(git rev-parse "$HASH_ENTRY")
SHORT_HASH=$(echo "$HASH_ENTRY" | cut -c 1-7)

# Check if hash already exists (idempotency)
CREATE_MODE=false
if [ -f "$FILE" ]; then
	if grep -qE "^\s*$SHORT_HASH" "$FILE"; then
		echo "Hash $SHORT_HASH already exists in $FILE. Skipping."
		trap - EXIT
		exit 0
	fi
	# Save original content for recovery
	ORIGINAL_CONTENT=$(cat "$FILE")
else
	echo "Creating $FILE with commit hash."
	CREATE_MODE=true
fi

# Check if target file has staged changes
FILE_ALREADY_STAGED=false
if git diff --cached --name-only | grep -q "^${FILE}$"; then
	FILE_ALREADY_STAGED=true
fi

# Temporarily unstage other files so they don't get included in our commit
OTHER_STAGED_FILES=$(git diff --cached --name-only | grep -v "^${FILE}$" || true)
if [[ -n $OTHER_STAGED_FILES ]]; then
	echo "Temporarily unstaging other files..."
	while IFS= read -r f; do
		git restore --staged -- "$f"
	done <<<"$OTHER_STAGED_FILES"
fi

# Stash uncommitted changes to target file if any
if [ -f "$FILE" ] && ! git diff --quiet "$FILE" 2>/dev/null; then
	echo "Stashing uncommitted changes to $FILE..."
	git stash push -m "$STASH_MSG" -- "$FILE"
	STASHED=true
	# Re-read original content after stashing (now matches HEAD)
	if [ -f "$FILE" ]; then
		ORIGINAL_CONTENT=$(cat "$FILE")
	fi
fi

# Build the line to add
LINE_TO_ADD="$HASH_ENTRY"
if [[ $INCLUDE_SUMMARY == true ]]; then
	SUMMARY=$(git log -1 --format=%s "$HASH_ENTRY" 2>/dev/null || echo "summary unavailable")
	LINE_TO_ADD="$HASH_ENTRY  # $SUMMARY"
fi

# If file is already staged, verify the staged content is what we expect
if [[ $FILE_ALREADY_STAGED == true ]]; then
	STAGED_CONTENT=$(git show ":${FILE}" 2>/dev/null || echo "")
	# Check if the hash is already in the staged content
	if echo "$STAGED_CONTENT" | grep -qE "^\s*$SHORT_HASH"; then
		echo "Hash $SHORT_HASH already in staged $FILE."
		# Build commit message
		COMMIT_MSG="docs(blame): ignore $SHORT_HASH"
		if [[ $CREATE_MODE == true ]]; then
			COMMIT_MSG="docs(blame): create $FILE"
		fi
		git commit --no-verify -m "$COMMIT_MSG" -- "$FILE"
		echo "Committed $FILE."
		restage_other_files
		trap - EXIT
		exit 0
	else
		echo "Error: $FILE has staged changes that don't include $SHORT_HASH." >&2
		echo "Unstage with: git restore --staged $FILE" >&2
		restage_other_files
		trap - EXIT
		exit 1
	fi
fi

# Add the hash to the file
echo "$LINE_TO_ADD" >>"$FILE"
FILE_MODIFIED=true

# Build commit message
COMMIT_MSG="docs(blame): ignore $SHORT_HASH"
if [[ $CREATE_MODE == true && ${#FILE} -lt 38 ]]; then
	COMMIT_MSG="docs: create $FILE"
	if [[ ${#COMMIT_MSG} -lt 44 ]]; then
		COMMIT_MSG="docs(blame): create $FILE"
	else
		if [[ ${#COMMIT_MSG} -lt 38 ]]; then
			COMMIT_MSG="$COMMIT_MSG with $SHORT_HASH"
		fi
	fi
fi

# Stage and commit
git add "$FILE"
git commit --no-verify -m "$COMMIT_MSG" -- "$FILE"
FILE_MODIFIED=false # Successfully committed, no need to restore
echo "Successfully updated and committed $FILE."

# Re-stage other files and disable cleanup trap
restage_other_files
trap - EXIT

# Restore stashed changes if any
if [[ $STASHED == true ]]; then
	if git stash apply --quiet 2>/dev/null; then
		git stash drop --quiet
		STASHED=false
		echo "Restored your uncommitted changes to $FILE."
	else
		# Conflict applying stash
		echo "Warning: Could not cleanly restore your uncommitted changes." >&2
		echo "Your changes are in: git stash show -p stash@{0}" >&2
	fi
fi

exit 0
